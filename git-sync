#!/data/data/com.termux/files/usr/bin/bash

# Résoudre le problème où parfois certains fichiers sont indexés et d'autres non, ce qui empêche la synchronisation
git reset HEAD

# git-sync
#
# synchroniser les dépôts de suivi
#
# 2012-20 par Simon Thum et contributeurs
# Licence : CC0
#
# Ce script vise à synchroniser via git presque automatiquement
# dans les dépôts de "suivi" où un historique précis n'est pas
# crucial, mais en avoir un l'est.
#
# Contrairement à la myriade de scripts déjà disponibles pour faire cela,
# il suit le principe KISS : il est petit, ne nécessite que git et bash,
# mais n'essaie même pas de vous protéger de git.

# Messages traduits en français

print_usage() {
    cat << EOF
usage: $0 [-h] [-n] [-s] [MODE]

Synchroniser la branche actuelle avec une sauvegarde distante
MODE peut être soit "sync" (par défaut) soit "check", pour vérifier que la branche est prête à être synchronisée

OPTIONS:
   -h      Afficher ce message
   -n      Commiter les nouveaux fichiers même si branch.\$branch_name.syncNewFiles n'est pas défini
   -s      Synchroniser la branche même si branch.\$branch_name.sync n'est pas défini
EOF
}

__log_msg()
{
    echo git-sync: $1
}

# Messages d'erreur et d'information traduits

if [[ "NOGIT" = "$rstate" ]] ; then
    __log_msg "Aucun dépôt git détecté. Sortie."
    exit 128 # correspond au code d'erreur de git
else
    __log_msg "L'état du dépôt git est considéré comme non sûr pour la synchronisation : $(git_repo_state)"
    exit 2
fi

if [ -z "$branch_name" ] ; then
    __log_msg "La synchronisation n'est possible que sur une branche."
    git status
    exit 2
fi

if [ -z "$remote_name" ] ; then
    __log_msg "La branche actuelle n'a pas de remote configuré."
    echo
    __log_msg "Veuillez utiliser"
    echo
    __log_msg "  git branch --set-upstream-to=[remote_name]/$branch_name"
    echo
    __log_msg "en remplaçant [remote_name] par le nom de votre remote, par exemple - origin"
    __log_msg "pour définir la branche de suivi distante pour que git-sync fonctionne"
    exit 2
fi

if [[ "true" != "$(git config --get --bool branch.$branch_name.sync)" && "true" != "$sync_anyway" ]] ; then
    echo
    __log_msg "Veuillez utiliser"
    echo
    __log_msg "  git config --bool branch.$branch_name.sync true"
    echo
    __log_msg "pour inscrire la branche $branch_name à la synchronisation."
    __log_msg "La branche $branch_name doit avoir une branche distante du même nom"
    __log_msg "pour que git-sync fonctionne."
    echo
    __log_msg "(Si vous ne savez pas ce que cela signifie, vous devriez changer cela"
    __log_msg "avant de vous fier à ce script. Vous avez été prévenu.)"
    echo
    exit 1
fi

if [[ -z "$1" || "$1" == "sync" ]]; then
    mode="sync"
elif [[ "check" == "$1" ]]; then
    mode="check"
else
    __log_msg "Mode $1 non reconnu"
    exit 100
fi

__log_msg "Mode $mode"

__log_msg "Utilisation de $remote_name/$branch_name"

if [ ! -z "$(check_initial_file_state)" ] ; then
    __log_msg "Il y a des fichiers modifiés que vous devriez probablement gérer manuellement."
    git status
    exit 1
fi

if [ $mode == "check" ] ; then
    __log_msg "Vérification OK ; la synchronisation peut commencer."
    exit 0
fi

if [ ! -z "$(local_changes)" ]; then
    __log_msg "Commit des changements locaux en utilisant ${autocommit_cmd}"
    eval $autocommit_cmd

    rstate="$(git_repo_state)"
    if [[ ! -z "$rstate" ]]; then
        __log_msg "L'auto-commit a laissé des changements non commités. Veuillez les ajouter ou les supprimer comme souhaité et réessayer."
        exit 1
    fi
fi

__log_msg "Récupération depuis $remote_name/$branch_name"
git fetch $remote_name $branch_name
if [ $? != 0 ] ; then
    __log_msg "git fetch $remote_name a retourné une erreur. Probablement un problème de réseau ; sortie."
    exit 3
fi

case "$(sync_state)" in
"noUpstream")
    __log_msg "État étrange, vous êtes livré à vous-même. Bonne chance."
    exit 2
    ;;
"equal")
    exit_assuming_sync
    ;;
"ahead")
    __log_msg "Envoi des changements..."
    git push $remote_name $branch_name:$branch_name
    if [ $? == 0 ]; then
        exit_assuming_sync
    else
        __log_msg "git push a retourné une erreur. Probablement un échec de connexion."
        exit 3
    fi
    ;;
"behind")
    __log_msg "Nous sommes en retard, avance rapide..."
    git merge --ff --ff-only $remote_name/$branch_name
    if [ $? == 0 ]; then
        exit_assuming_sync
    else
        __log_msg "git merge --ff --ff-only a retourné une erreur ($?). Sortie."
        exit 2
    fi
    ;;
"diverged")
    __log_msg "Nous avons divergé. Tentative de rebase..."
    git rebase $remote_name/$branch_name
    if [[ $? == 0 && -z "$(git_repo_state)" && "ahead" == "$(sync_state)" ]] ; then
        __log_msg "Le rebase s'est bien passé, envoi..."
        git push $remote_name $branch_name:$branch_name
        exit_assuming_sync
    else
        __log_msg "Le rebase a échoué, il y a probablement des changements conflictuels. Résolvez-les et terminez le rebase avant de répéter git-sync."
        exit 1
    fi
    ;;
esac